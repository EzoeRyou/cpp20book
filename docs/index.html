<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="江添亮" />
  <meta name="dcterms.date" content="2019-08-08" />
  <title>江添亮の詳説C++20</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  </style>
</head>
<body>
<header>
<h1 class="title">江添亮の詳説C++20</h1>
<p class="author">江添亮</p>
<p class="date">2019-08-08</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#序">序</a></li>
<li><a href="#c20の概要">C++20の概要</a></li>
<li><a href="#コア言語の変更点">コア言語の変更点</a><ul>
<li><a href="#ビットフィールドに対するデフォルトメンバー初期化子">ビットフィールドに対するデフォルトメンバー初期化子</a></li>
<li><a href="#constリファレンス修飾子のついたメンバーへのポインターの修正">constリファレンス修飾子のついたメンバーへのポインターの修正</a></li>
<li><a href="#ラムダキャプチャー-thisの制限緩和">ラムダキャプチャー、<code>[=, this]</code>の制限緩和</a></li>
<li><a href="#による暗黙のthisのキャプチャーの廃止予定"><code>[=]</code>による暗黙のthisのキャプチャーの廃止予定</a></li>
<li><a href="#va_opt__"><code>__VA_OPT__</code></a></li>
</ul></li>
<li><a href="#指示初期化子designated-initializers">指示初期化子(designated-initializers)</a><ul>
<li><a href="#ラムダ式に従来のテンプレート文法の追加">ラムダ式に従来のテンプレート文法の追加</a></li>
</ul></li>
</ul>
</nav>
<h1 id="序">序</h1>
<p>C++20の新機能を解説する。</p>
<h1 id="c20の概要">C++20の概要</h1>
<p>C++20は2020年に制定されたは国際標準規格だ。C++は厳格に3年おきに規格を制定するスケジュールを敷いている。そのため、C++20の前の規格は2017年に制定されたC++17で、次の規格はおそらく2023年に制定されるC++23になるだろう。</p>
<p>近年C++が厳格に3年おきに規格を制定するようになったのは、過去の二度の失敗から学んだためだ。C++での最初の規格、C++98は1998年に制定されたが、この規格は本来、1990年台の前半までに制定できなければ失敗だと言われていた。C++11は2011年に制定されたが、この規格は本来200x年までに制定される予定であったので、C++0xと呼ばれていた。</p>
<p>なぜかつてのC++の規格が本来の予定を大幅に超過して制定されたかというと、スケジュール管理の目標に問題があったためだ。スケジュール管理をする場合の目標設定として以下の2つが考えられる。</p>
<ul>
<li>機能に対する目標</li>
<li>期間に対する目標</li>
</ul>
<p>機能を目標として設定すると、ある機能Xが完成するまでリリースができなくなる。そのため、リリース時期は機能Xが完成するまで際限なく引き伸ばされる。</p>
<p>期間を目標にするとどうか。期間を区切って、何日後や何ヶ月後のこの日に必ずリリースすると宣言する。その場合、納期に間に合わなかった機能は含まれなくなる。</p>
<p>スケジュール管理の目標は機能か期限のどちらかしか選ぶことはできず、一方を選ぶと他方は諦めなければならない。C++ではC++98とC++11で機能を目標としたスケジュール管理をしてきた。そのため、C++に入れる予定の機能が完成するまで際限なく規格制定が延期されることになった。正式に制定されていない規格は、将来変わる可能性があるので、C++コンパイラーは積極的に機能を実装しようとはせず、機能が実装されないので実装経験や利用経験も積まれず、もうそろそろ完成という段階になって新たに不具合が見つかり完成が遠のくという負のスパイラルに陥っていた。</p>
<p>そのため、C++14からはC++標準化委員会は厳格に3年おきに標準規格を制定するというスケジュール管理戦略を取った。ある機能が今回の3年の期限に間に合わなかったならば、次の3年に回される。「でもあと一回会議をはさめば合意が取れるから」と言い訳をして実際にそのとおりになったためしはない。間に合わなければ問答無用で次回以降に持ち越しだ。</p>
<p>C++20ではこのようにして次回に持ち越された成熟を重ねてきた機能が多く採用されることになった。特に大きな機能だけでも、</p>
<ul>
<li>コンセプト</li>
<li>コルーチン</li>
<li>モジュール</li>
</ul>
<p>があるし、ライブラリとしても</p>
<ul>
<li>レンジ</li>
<li>std::format</li>
</ul>
<p>がある。また、今回はconstexprの制限がさらに大幅に緩和された。この制限緩和は将来のさらなる機能追加のための布石だ。C++はまだまだ進化を続ける言語だ。</p>
<p>本書はC++17の知識を持っている読者を対象にC++20に追加された新機能を解説する。まだC++17までの知識を得ていない読者は、拙書「C++11/14コア言語」や「江添亮の詳説C++17」などで学ぶとよい。</p>
<h1 id="コア言語の変更点">コア言語の変更点</h1>
<p>この章ではC++20でコア言語に対して行われた変更を説明していく。特に大きな新機能や、ライブラリと合わせて解説する必要があるコア言語機能は、別に章を分けて説明する。</p>
<h2 id="ビットフィールドに対するデフォルトメンバー初期化子">ビットフィールドに対するデフォルトメンバー初期化子</h2>
<p>C++14ではデータメンバーに対してデフォルトメンバー初期化子を書くことができるようになった。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1-2" title="2">{</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="dt">int</span> member = <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb1-4" title="4">} ;</a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">S s ;</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">// s.member == 3</span></a></code></pre></div>
<p>C++20ではビットフィールドであるデータメンバーに対して、このデフォルトメンバー初期化子を書くことができるようになった。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb2-2" title="2">{</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="dt">int</span> upper : <span class="dv">4</span> = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="dt">int</span> lower : <span class="dv">4</span> {<span class="dv">2</span>} ;</a>
<a class="sourceLine" id="cb2-5" title="5">} ;</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">S s ;</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="co">// s.upper == 1</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">// s.lower == 2</span></a></code></pre></div>
<p>文法は以下の通り。</p>
<pre><code>識別子  :   定数式  {}もしくは=による初期化子</code></pre>
<h2 id="constリファレンス修飾子のついたメンバーへのポインターの修正">constリファレンス修飾子のついたメンバーへのポインターの修正</h2>
<p>C++17までは以下のコードがエラーとなっていた。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">struct</span> X { <span class="dt">void</span> foo() <span class="at">const</span>&amp;; };</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3">X{}.foo();        <span class="co">// OK</span></a>
<a class="sourceLine" id="cb4-4" title="4">(X{}.*&amp;X::foo)(); <span class="co">// エラー</span></a></code></pre></div>
<p>これはconstなリファレンス修飾子のエラーとなるべきコードではないが、規格の文面上の問題でC++17まではエラーになっていた。C++20で修正された。</p>
<h2 id="ラムダキャプチャー-thisの制限緩和">ラムダキャプチャー、<code>[=, this]</code>の制限緩和</h2>
<p>C++17まで、デフォルトラムダキャプチャー<code>[=]</code>を書くと、<code>[this]</code>と書いた場合と同じように振る舞った。デフォルトキャプチャー<code>[=]</code>を書いた場合、後続の個別のキャプチャーにはコピーキャプチャーを書くことができない。その理由は冗長だからだ。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">int</span> x { }</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">// エラー、デフォルトキャプチャー=が指定されているのに</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">// 個別のコピーキャプチャーを指定した</span></a>
<a class="sourceLine" id="cb5-4" title="4">[=, x]{} ;</a></code></pre></div>
<p>すでにデフォルトキャプチャーでコピーキャプチャーするということを明示しているので、個別にコピーキャプチャーを指定するのは冗長で間違いの下だという理由からこの制限がある。</p>
<p>ただし、thisポインターについてはデフォルトキャプチャーでthisポインターがコピーキャプチャーされる仕様が廃止予定になったことと、C++17で*thisのコピーキャプチャーが追加されたので、対比したわかりやすさのために、制限緩和が行われた。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb6-2" title="2">{</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="dt">int</span> member ;</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb6-5" title="5">    {</a>
<a class="sourceLine" id="cb6-6" title="6">        <span class="co">// thisポインターがコピーキャプチャーされる</span></a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="co">// memberはポインターを経由した関節アクセス</span></a>
<a class="sourceLine" id="cb6-8" title="8">        [=, <span class="kw">this</span>] { member ; }() ;</a>
<a class="sourceLine" id="cb6-9" title="9">        <span class="co">// *thisがコピーキャプチャーされる</span></a>
<a class="sourceLine" id="cb6-10" title="10">        <span class="co">// memberはコピー</span></a>
<a class="sourceLine" id="cb6-11" title="11">        [=, *<span class="kw">this</span>] { member ; }() ;</a>
<a class="sourceLine" id="cb6-12" title="12">    }</a>
<a class="sourceLine" id="cb6-13" title="13">} ;</a></code></pre></div>
<p><code>[*this]</code>は<code>*this</code>をコピーキャプチャーする。そのため上のコードは、実質以下のようなコードと等しい。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb7-2" title="2">{</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="co">// thisポインターがコピーキャプチャーされる</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="co">// メンバーは実質リファレンス</span></a>
<a class="sourceLine" id="cb7-5" title="5">    S * capture1 = <span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb7-6" title="6">    capture1-&gt;member ;</a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="co">// *thisがコピーキャプチャーされる</span></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="co">// memberはコピー</span></a>
<a class="sourceLine" id="cb7-9" title="9">    S capture2 = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb7-10" title="10">    capture2.member ;</a>
<a class="sourceLine" id="cb7-11" title="11">}</a></code></pre></div>
<p>C++17までは<code>[=, this]</code>と書くとエラーになる。</p>
<h2 id="による暗黙のthisのキャプチャーの廃止予定"><code>[=]</code>による暗黙のthisのキャプチャーの廃止予定</h2>
<p>C++17までは、ラムダ式のデフォルトキャプチャー<code>[=]</code>はthisポインターをキャプチャする。この挙動はC++20では廃止予定となった。C++20ではまだこの挙動に従うが、将来は廃止される予定だ。C++20からは、明示的に<code>[this]</code>を使う必要がある。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb8-2" title="2">{</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="dt">int</span> member ;</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb8-5" title="5">    {</a>
<a class="sourceLine" id="cb8-6" title="6">        <span class="co">// C++17までは合法</span></a>
<a class="sourceLine" id="cb8-7" title="7">        <span class="co">// C++20では廃止予定で非推奨</span></a>
<a class="sourceLine" id="cb8-8" title="8">        [=}{ member ; } ;</a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10">        <span class="co">// C++20以降で合法</span></a>
<a class="sourceLine" id="cb8-11" title="11">        <span class="co">// 意味はC++17までの上と同じ</span></a>
<a class="sourceLine" id="cb8-12" title="12">        [=, <span class="kw">this</span>] { member ; } ;</a>
<a class="sourceLine" id="cb8-13" title="13">    }</a>
<a class="sourceLine" id="cb8-14" title="14">} ;</a></code></pre></div>
<p>C++11で追加されたラムダ式のデフォルトキャプチャー<code>[=]</code>は、thisポインターをコピーキャプチャーする。thisポインターの参照する先のオブジェクトの値をコピーしているわけではない。コピーしているのはポインターであるので、メンバーへのアクセスはポインターを経由した関節アクセスになる。</p>
<p>この挙動は混乱の元であったので、C++14では明示的なキャプチャーである<code>[name = expr]</code>が追加された。C++17では<code>this</code>ポインターの参照先、すなわち<code>*this</code>をコピーキャプチャーする専用のキャプチャーである<code>[*this]</code>が追加された。C++20では将来廃止するために、デフォルトキャプチャー<code>[=]</code>ではthisポインターをコピーキャプチャーする挙動を廃止予定とした。</p>
<h2 id="va_opt__"><code>__VA_OPT__</code></h2>
<p><code>__VA_OPT__</code>は可変引数マクロの中で使う識別子だ。</p>
<p>C99とC++11で追加された<code>__VA_ARGS__</code>によって、プリプロセッサーは可変引数マクロに対応した。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Types &gt;</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="dt">void</span> f( Types &amp;&amp; ... args ) ;</a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="pp">#define F</span>(<span class="pp"> </span>X,<span class="pp"> </span>...<span class="pp"> </span>)<span class="pp"> </span>f(<span class="pp"> </span>X,<span class="pp"> </span><span class="ot">__VA_ARGS__</span><span class="pp"> </span>)</a>
<a class="sourceLine" id="cb9-5" title="5"></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="co">// f( 0, 1, 2, 3 )</span></a>
<a class="sourceLine" id="cb9-7" title="7">F( <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;</a></code></pre></div>
<p>可変引数マクロはゼロ個のトークンに対応できない問題があった。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="co">// エラー、文法上余計なカンマ</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">// f( 0, )</span></a>
<a class="sourceLine" id="cb10-3" title="3">F( <span class="dv">0</span> ) ;</a></code></pre></div>
<p>このようにゼロ個のトークン列を渡すと、余計なカンマが存在するためにエラーとなってしまう。</p>
<p><code>__VA_OPT__</code>はこのような場合に、選択的にカンマに置換される識別子だ。</p>
<p><code>__VA_OPT__(tokens)</code>は、可変引数マクロの置換リストの中に書くことができる。もし<code>__VA_ARGS__</code>がゼロ個のトークンである場合、空のトークンに置換される。そうでない場合、<code>tokens</code>に置換される。</p>
<pre class="c~~"><code>#define F( X, ... ) f( X __VA_OPT(,) __VA_ARGS__ )

// f( 0, 1, 2, 3 )
// __VA_OPT__(,)は,
// __VA_ARGS__は1,2,3
F( 0, 1, 2, 3 )
// f(0)
// __VA_OPT__(,)は空
// __VA_ARGS__は空
F( 0 ) </code></pre>
<p>これによって選択的にカンマのようなトークン列に置換させることができ、ゼロ個の引数に対応した可変引数マクロを作ることができる。</p>
<h1 id="指示初期化子designated-initializers">指示初期化子(designated-initializers)</h1>
<p>指示初期化子(designated-initializers)はC99で追加された機能だ。C++20にはC99よりも機能を制限した指示初期化子が追加された。</p>
<p>指示初期化子とは、クラスのオブジェクトのリスト初期化において、クラスの非staticデータメンバーの名前を記述できる機能だ。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">struct</span> S { <span class="dt">int</span> x, y, z ; } ;</a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co">// S s{1,2,3}と同じ</span></a>
<a class="sourceLine" id="cb12-4" title="4">S s1 { .x = <span class="dv">1</span>, .y = <span class="dv">2</span>, .z = <span class="dv">3</span> } ;</a>
<a class="sourceLine" id="cb12-5" title="5">S s2 = { .x = <span class="dv">1</span>, .y = <span class="dv">2</span>, .z = <span class="dv">3</span> } ;</a></code></pre></div>
<p>文法は、ドット(.)に続いて非staticデータメンバーの識別子を書き、<code>=</code>を書き、初期化の式を書く。</p>
<pre><code>{ . 識別子 = 式, ... }</code></pre>
<p>C++20の指示初期化子は、C99の指示初期化子の機能制限版だ。</p>
<p>識別子はクラスの非staticデータメンバー名を宣言順に書かなければならない。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">struct</span> S { <span class="dt">int</span> x, y ; } ;</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co">// C99では合法</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="co">// C++20では違法、宣言順ではない</span></a>
<a class="sourceLine" id="cb14-5" title="5">S s{ y. = <span class="dv">0</span>, x = <span class="dv">0</span> }</a></code></pre></div>
<p>C99では宣言順に書かなくてもよいが、。C++20では宣言順に書かなければならない。</p>
<p>C99では配列を指示初期化できるが、C++20ではできない。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="co">// C99では合法</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="co">// C++20では違法</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="dt">int</span> a[<span class="dv">3</span>] = { [<span class="dv">1</span>] = <span class="dv">1</span>, [<span class="dv">0</span>] = <span class="dv">2</span>, [<span class="dv">2</span>] = <span class="dv">3</span> } ;</a></code></pre></div>
<p>C99では指示初期化子のネストができるが、C++20ではできない。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">struct</span> A { <span class="dt">int</span> x ; } ;</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">struct</span> B { <span class="kw">struct</span> A a ; } ;</a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="co">// C99では合法</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="co">// C++20では違法</span></a>
<a class="sourceLine" id="cb16-6" title="6">B b{ .a.x = <span class="dv">0</span> } ;</a></code></pre></div>
<p>C99では指示初期化子と通常の初期化子を混ぜることができるが、C++20ではできない。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">struct</span> S { <span class="dt">int</span> x, y ; } ;</a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="co">// C99では合法</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="co">// C++20では違法</span></a>
<a class="sourceLine" id="cb17-5" title="5">S s{ .x = <span class="dv">0</span>, <span class="dv">1</span> } ;</a></code></pre></div>
<p>このような制限がある理由としては、C++ではオブジェクトの破棄は構築の逆順に行われ、初期化リストの要素の評価は表記順に行われるために、指示初期化子でも宣言順に記述しなければならない制限が加えられた。配列の指示初期化子はラムダ式と文法が衝突するために採用されなかった。指示初期化子のネストはC99でもまれにしか使われていないので採用されなかった。</p>
<h2 id="ラムダ式に従来のテンプレート文法の追加">ラムダ式に従来のテンプレート文法の追加</h2>
<p>C++20ではラムダ式に従来のテンプレートの文法に近いテンプレートパラメーターの記述ができるようになった。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1">[]&lt;<span class="kw">typename</span> T&gt;(T x ) { <span class="cf">return</span> x ; } ;</a></code></pre></div>
</body>
</html>
