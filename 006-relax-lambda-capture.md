## ラムダキャプチャー、`[=, this]`の制限緩和

C++17まで、デフォルトラムダキャプチャー`[=]`を書くと、`[this]`と書いた場合と同じように振る舞った。デフォルトキャプチャー`[=]`を書いた場合、後続の個別のキャプチャーにはコピーキャプチャーを書くことができない。その理由は冗長だからだ。

~~~c++
int x { }
// エラー、デフォルトキャプチャー=が指定されているのに
// 個別のコピーキャプチャーを指定した
[=, x]{} ;
~~~

すでにデフォルトキャプチャーでコピーキャプチャーするということを明示しているので、個別にコピーキャプチャーを指定するのは冗長で間違いの下だという理由からこの制限がある。

ただし、thisポインターについてはデフォルトキャプチャーでthisポインターがコピーキャプチャーされる仕様が廃止予定になったことと、C++17で*thisのコピーキャプチャーが追加されたので、対比したわかりやすさのために、制限緩和が行われた。

~~~cpp
struct S
{
    int member ;
    void f()
    {
        // thisポインターがコピーキャプチャーされる
        // memberはポインターを経由した関節アクセス
        [=, this] { member ; }() ;
        // *thisがコピーキャプチャーされる
        // memberはコピー
        [=, *this] { member ; }() ;
    }
} ;
~~~

`[*this]`は`*this`をコピーキャプチャーする。そのため上のコードは、実質以下のようなコードと等しい。

~~~cpp
void f()
{
    // thisポインターがコピーキャプチャーされる
    // メンバーは実質リファレンス
    S * capture1 = this ;
    capture1->member ;
    // *thisがコピーキャプチャーされる
    // memberはコピー
    S capture2 = *this ;
    capture2.member ;
}
~~~


C++17までは`[=, this]`と書くとエラーになる。
