## 構造化束縛をアクセス可能なメンバーにも適用

構造化束縛の以前の規定では、publicなメンバーのみのクラス型しか束縛できなかった。

~~~c++
struct S
{
    friend void f() ;
private :
    int a ;
public :
    int b ;
} ;

void f( S s )
{
    // かつてのC++17の文面ではエラー
    // publicなメンバーのみではない
    auto[ a, b ] = s ;
}
~~~

この規定は一貫性に欠ける。というのも、C++ではアクセス指定は名前の利用時にアクセス指定の確認が行われるだけで、名前の発見を妨げたりはしないものだからだ。

~~~c++
struct S
{
private :
    void f( int ) ;
public :
    void f( double ) ;
} ;

int main()
{
    S s ;
    // アクセスチェックによりエラー
    s.f(0) ;
}
~~~

この例では、名前解決により`S::f(int)`と`S::f(double)`が発見され、オーバーロード解決により`S::f(int)`が選ばれる。しかし、`S::f(int)`はprivateメンバーなのでアクセス指定の確認に引っかかりエラーとなる。アクセス指定は名前を使うときに確認されるのであって、名前検索で見つからなくなるわけでない。

C++20では、この規定を変更し、構造化束縛でもアクセス指定にかかわらずすべてのメンバーが考慮されるようになった。アクセス指定の確認は通常通り、名前を使うときに行われる。

~~~cpp
struct S
{
    friend void f() ;
private :
    int a ;
public :
    int b  ;
} ;

void f( S s )
{
    // OK
    // fはSのfriendなのでprivateメンバーにアクセスできる
    auto[ a,b ] = s ;
}

void g( S s )
{
    // エラー
    // privateメンバーへのアクセス
    auto [ a, b ] = s ;
}
~~~

この変更はC++の問題の修正にあたり、C++20だけではなく、C++17にも適用される。そのためC++17の挙動も変わる。
