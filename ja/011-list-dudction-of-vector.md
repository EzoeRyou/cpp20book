## vectorに対するリスト推定

この変更は規格上の不備を修正したもので、一般のC++プログラマーは知っていてもそれほど恩恵はない。結論だけを先に書くと、以下のようなコードで、

~~~cpp
std::vector v { std::vector{1,2} } ;
~~~

変数`v`の型は`std::vector<int>`になる。

C++17までの規格の文面は、このとき変数`v`の型が`std::vector<std::vector<int>>`になる解釈の余地を残していた。C++20ではそのような解釈の余地をなくした。

C++11ではリスト初期化が追加された。クラスがリスト初期化されたとき、クラスのコンストラクターに初期化リストコンストラクターがある場合は、初期化リストコンストラクターがオーバーロード解決で優先して使われる。

~~~cpp
template < typename T >
struct vector
{
    // 初期化リストコンストラクター
    vector( std::initializer_list<T> l ) ;
    // コピーコンストラクター
    vector( const vector & other ) ;
} ;

// 初期化リストコンストラクターが使われる
vector<int> v = {123} ;
~~~

C++17では、クラステンプレートのコンストラクターからの実引数推定が追加された。

~~~c++
// 初期化コンストラクターが使われる
// vector<int>
vector v = {123} ;
~~~

`vector<T>`のテンプレート仮引数`T`は、初期化リストコンストラクターの`std::initializer_list<T>`の`T`をテンプレート実引数として推定される。

すると、以下の場合、

~~~cp++
vector v = { vector{1,2} } ;
~~~

`vector{1,2}`の型は`vector<int>`だ。`v`はリスト初期化されているので、初期化リストコンストラクターが使われる。このとき、`std::initializer_list<T>`の`T`は`vector<int>`、つまり`std::initializer_list<vector<int>>`となる。すると、変数`v`のクラステンプレート`vector<T>`の`T`は`vector<int>`となる。つまり、変数`v`の型は`vector<vector<int>>`となってしまう。

この挙動は人間にとって不自然なので、この場合に`vector`のコピーコンストラクターが呼ばれ、`v`の型は`vector<int>`となることを明記した。

具体的には、クラステンプレートのコンストラクターからの実引数推定が行われるときで、リスト初期化が使われ、かつリスト初期化の中の要素がひとつだけで、その要素の型が初期化されるクラステンプレートの特殊化であった場合は、初期化リストコンストラクターは選ばれない。

つまり、以下のような場合で、

~~~c++
C x = { U{} } ;
~~~

`C`がクラステンプレート、`U`が`C`の特殊化であった場合は、`C`の初期化リストコンストラクターは選ばれなくなる。

