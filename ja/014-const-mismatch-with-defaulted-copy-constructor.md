## デフォルト化されたコピーコンストラクターにおけるconst修飾子の違いを許容する制限緩和

この変更は重要だが、平均的なC++プログラマーは詳細を知る必要がないので、読み飛ばしてもよい。

仮引数の型が非constなリファレンスのコピーコンストラクターを持つクラスがある。

~~~cpp
struct A
{
    A() = default ;
    // 仮引数の型が非constなリファレンスの
    // コピーコンストラクター
    A( A & ) { }
} ;
~~~

このようなクラスを基本クラスやメンバーにもつクラスがある。

~~~c++
// 基本クラスに持つ
struct B : A { } ;
// メンバーに持つ
struct C { A a } ;
~~~

このとき、クラスB, Cが、仮引数の型がconstなリファレンスのdefault化されたコピーコンストラクターを持つとき、C++17ではたとえB, Cをコピーしなくても、結果の型は違法になる。

~~~c++
struct C
{
    A a ;
    C() = default ;
    C( const C & ) = default ;
}

// C++17では違法
C c ;
~~~

理由は、const修飾子が異なるからだ。たとえクラスが実際にはコピーされていないとしても違法になる。

このような制約は不必要に厳しいので、C++20では制限緩和が行われた。C++20では、このような場合、コピーしない限り合法となる。

~~~c++
// C++20では合法
C c ; 
// C++20でも違法
C copy = c ;
~~~

この制限緩和の恩恵を最も受けるのは`std::tuple`だ。この制限緩和によって、`std::tuple`が使いやすくなる。
