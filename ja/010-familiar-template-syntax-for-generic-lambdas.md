## ラムダ式に馴染み深いテンプレート文法の追加

C++20ではラムダ式に従来のテンプレートの文法によく似た馴染み深いテンプレートパラメーターの記述ができるようになった。

~~~cpp
[]<typename T>( T x ) { return x ; } ;
~~~

このラムダ式と同等のものを関数テンプレート風に書くと以下のようになる。

~~~cpp
template < typename T >
auto f( T x )
{
    return x ;
}
~~~

文法は、ラムダ式のラムダ導入子(lambda-introducer, `[]`)とラムダ宣言子(仮引数リストなど)の間に、テンプレート仮引数リストを書く。

~~~cpp
[]              // ラムダ導入子
< typename T >  // テンプレート仮引数リスト
( T x )         // ラムダ宣言子
{ }             // 複合文
~~~

この文法を導入した理由は2つある。

1つには、テンプレート仮引数リストが書けない場合、関数テンプレートとは同じように書けないラムダ式が存在することへの対処だ。

例えば以下の関数テンプレートを考える。

~~~cpp
template < typename T >
auto f( T x, T y )
{ return x + y ; }
~~~

この関数テンプレートと同等のラムダ式書こうとして、以下のように書いた場合、

~~~cpp
[]( auto x, auto y ){ return x + y }
~~~

これは厳密に同じ意味ではない。以下のような関数テンプレートを書いたものと同じになる。

~~~cpp
template < typename T, typename U >
auto lambda( T x, U y )
{ return x + y ; }
~~~

元々の関数のx, yは同じ型になるが、ラムダ式のx,yの型はそれぞれ別になりうる。ラムダ式に馴染み深いテンプレートの文法を導入することで、関数テンプレートとラムダ式が同じ表現力を持つようになる。

もう一つの導入理由としては、制約テンプレートだ。コンセプトA, B, Cを同時に満たす制約テンプレートを関数テンプレートで書くと以下のようになる。

~~~cpp
template < typename T >
    requires A<T> && B<T> && C<T>
void f( T x ) { }
~~~

このような制約テンプレートを従来のラムダ式で書くには、まずコンセプトA, B, Cを満たすコンセプトを定義し、そのコンセプトを使わなければならない。

~~~cpp
template < typename T >
concept ABC = A<T> && B<T> && C<T> ;

[]( ABC auto x ) { } ;
~~~

C++20では、ラムダ式に従来のテンプレートの文法が使えるようになったので、以下のように書くことができる。

~~~cpp
[]
< typename T >
    requires A<T> && B<T> && C<T>
( T x ) { } ;
~~~
