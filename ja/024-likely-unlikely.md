## [[likely]]と[[unlikely]]

C++20では新しい属性として、`[[likely]]`と`[[unlikely]]`が追加された。この属性はラベルもしくは文に記述する。

~~~c++
int main()
{
// 式文の例
[[likely]] do_something() ;
// ブロック文の例
[[unlikely]] { do_something() ; } ;

// ラベル文の例
    goto likely_label ;

[[likely]] likely_label : do_something() ;
}
~~~

likelyとunlikelyを同時に書くことはできない。

~~~c++
int main()
{
// エラー
[[likely, unlikely]] do_something() ;
}
~~~

likely属性が指定された文を含む実行パスは、実行される可能性が高い(likely)ことを意味する。unlikely属性が指定された文を含む実行パスは、実行される可能性が低い(unlikely)ことを意味する。コンパイラーはこの情報をコード生成の際の最適化に利用できる。

~~~cpp
// 現在の状態が正常かどうか調べる関数
// 通常はtrueを返す
bool sanity_check() ;

int main()
{
    while (true)
    {
        // 状態が正常でなければabort
        if ( !sanity_check() )
            [[unlikely]] std::abort() ;

        // 正常なので次の処理をする
        do_next_work() ;
    }
}
~~~

このコードは、ループを回して何らかの処理を行うプログラムだ。現在の状態が正常かどうかを処理ごとに確認し、正常でない場合はただちにabortする。正常でない状態は通常は起こりえないことが期待できる場合は、このようにコンパイラーにヒントを与えることができる。

この場合はひとつの式文に適用しているが、よくあるコードとしては、ブロック文に適用するものだろう。


~~~cpp
// 現在の状態が正常かどうか調べる関数
// 通常はtrueを返す
bool sanity_check() ;

int main()
{
    while (true)
    {
        // 状態が正常でなければabort
        if ( !sanity_check() ) [[unlikely]] {
            // 終了処理
            cleanup() ;
            // 強制終了
            std::abort() ;
        }

        // 正常なので次の処理をする
        do_next_work() ;
    }
}
~~~

コンパイラーがどのような最適化をするかはアーキテクチャーごとに異なる。例えば、条件分岐命令自体に実行する可能性の高いブランチを指定する機能がついているアーキテクチャーが存在する。あるいは、実行されやすいコードを局所的に固めて配置したり、実行されにくいコードを離して配置することにより、プロセッサーのキャッシュに乗りやすくするコード生成などが考えられる。この情報をどのように買うかはコンパイラーの実装次第であり、過剰に利用するとむしろパフォーマンスを下げることにもなる。
