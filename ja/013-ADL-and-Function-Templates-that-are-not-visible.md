## ADLと見えない関数テンプレート

このC++20の変更はほとんどのC++プログラマーには関係がないので読み飛ばすことをおすすめする。

関数テンプレート名に続いて`<`がある場合、それはテンプレート実引数の指定だ。

~~~c++
template < typename T >
void f() ;

f<int>() ;
~~~

しかし、`<`は比較演算子としても使われている。名前`f`が関数テンプレートではない場合は比較演算子として解釈される。

~~~c++
int main()
{
    int f = 0 ;
    f < 1 ;
}
~~~

ここで、名前`f`は関数テンプレート名だが、ADL経由でしか見つからない場合を考える。

~~~cpp
namespace NS {
    struct S { } ;
    template < typename T >
    // NS::f
    void f( S ) { }
}

int main()
{
    // C++17では違法
    // C++20では合法
    f<NS::S>( NS::S{} ) ;
}
~~~

C++17ではこのコードにおける`f`に続く`<`は比較演算子だとみなされ、このコードは違法になる。

C++20ではルールが変更された。非修飾名に続いて`<`がある場合で、通常の名前検索では名前が見つからないか、関数名が見つかった場合、その名前はテンプレート名だとみなされ、ADLが行われる。
したがって、上記のコードはC++20では合法になる。、非修飾名`f`は見つからないので、ADLが行われ、連想名前空間に`NS`があることにより、名前`NS::f`がADLにより発見される。後続の`<`はテンプレート実引数の指定隣合法とみなされる。

以下のような場合も、C++17では違法だが、C++20では合法なコードだ。


~~~cpp
// 関数名::f
void f() { }

namespace ns {
    struct s { } ;
    template < typename t >
    // ns::f
    void f( s ) { }
}

int main()
{
    // c++17ではill-formed
    // c++20ではwell-formed
    f<ns::s>( ns::s{} ) ;
}
~~~

この場合、非修飾名`f`に対して通常の名前検索で、グローバル名前空間にある`::f`が見つかる。`::f`は関数名なので、後続する`<`があるため、名前`f`はテンプレート名だとみなされる。テンプレート名は見つからないので続いてADLが行われ、'NS::f'が発見される。`::f`はテンプレート名ではないが、関数名なのでこのような挙動になる。ルールは「非修飾名に続いて`<`があり、通常の名前検索で名前が見つからないか、関数名が見つかった場合は、その名前はテンプレート名とみなされる」だからだ。

以下のような場合は違法だ。


~~~cpp
// 非関数名::f
int x {} ;

namespace ns {
    struct s { } ;
    template < typename t >
    // ns::f
    void f( s ) { }
}

int main()
{
    // c++17ではill-formed
    // c++20でもill-formed
    f<ns::s>( ns::s{} ) ;
}
~~~

この場合、'::f'は関数名ではないので、追加のADLは行われず、名前`f`はint型の変数xになる。この文脈では違法なので、結果は違法になる。
